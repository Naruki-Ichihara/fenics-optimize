<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>optfx.core API documentation</title>
<meta name="description" content="The code is a Python module that defines an abstract class called Module.
This class is the core of an optimization problem and defines the basic â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>optfx.core</code></h1>
</header>
<section id="section-intro">
<p>The code is a Python module that defines an abstract class called Module.
This class is the core of an optimization problem and defines the basic methods and attributes
that are required for optimization. The Module class is defined using the ABCMeta metaclass,
which makes it an abstract class that cannot be instantiated directly.</p>
<p>The Module class is inherited by the OptimizationProblem class, which is the main class of the
fenics-optimize package. The OptimizationProblem class is used to define an optimization problem
and to solve it using the optimize function.
The problem method is overloaded in the OptimizationProblem class to define the objective function.</p>
<p>The objective argument is the objective function that is being optimized,
the controls argument is a list of the control variables, and the wrt argument is a list of the indices
of the controls for which sensitivities need to be computed.</p>
<p>If the wrt argument is an iterable, the method computes the sensitivities for each control variable
whose index is in the wrt list. For each control variable,
the method creates a Control object and computes the gradient of the objective function with respect to
that control variable using the compute_gradient function from the fenics_adjoint module.
The sensitivities are then converted to a NumPy array using the to_numpy function from the utils module.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#! /usr/bin/python3
# -*- coding: utf-8 -*-
&#39;&#39;&#39; The code is a Python module that defines an abstract class called Module.
This class is the core of an optimization problem and defines the basic methods and attributes
that are required for optimization. The Module class is defined using the ABCMeta metaclass, 
which makes it an abstract class that cannot be instantiated directly.

The Module class is inherited by the OptimizationProblem class, which is the main class of the
fenics-optimize package. The OptimizationProblem class is used to define an optimization problem
and to solve it using the optimize function. 
The problem method is overloaded in the OptimizationProblem class to define the objective function.

The objective argument is the objective function that is being optimized,
the controls argument is a list of the control variables, and the wrt argument is a list of the indices
of the controls for which sensitivities need to be computed.

If the wrt argument is an iterable, the method computes the sensitivities for each control variable 
whose index is in the wrt list. For each control variable, 
the method creates a Control object and computes the gradient of the objective function with respect to 
that control variable using the compute_gradient function from the fenics_adjoint module. 
The sensitivities are then converted to a NumPy array using the to_numpy function from the utils module.

&#39;&#39;&#39;
from abc import ABCMeta, abstractmethod
from collections.abc import Iterable
from fenics import *
from fenics_adjoint import *
import numpy as np
from .utils import to_numpy

class Module(metaclass=ABCMeta):
    index = int(0)
    log_obj = [0]
    &#39;&#39;&#39;
    Core module of the fenics-optimize. The Module class is an abstract class that defines 
    the basic methods and attributes of the optimization problem.
    &#39;&#39;&#39;     
    def __compute_sensitivities(self, objective, controls, wrt) -&gt; list[np.ndarray]:
        &#39;&#39;&#39;Computes the sensitivities of the optimization problem with respect to the control variables.

        Args:
            objective: The objective function being optimized.
            controls: A list of the control variables.
            wrt: Either an integer index or a list of integer indices indicating which control variables to compute sensitivities for.

        Returns:
            A list of NumPy arrays containing the sensitivities of the objective function with respect to the specified control variables.
        &#39;&#39;&#39;
        if isinstance(wrt, Iterable):
            sensitivities_numpy = []
            for i in range(len(controls)):
                if i not in wrt:
                    sensitivities_numpy.append(to_numpy(controls[i])*0.0)
                else:
                    control = Control(controls[i])
                    sensitivities_numpy.append(to_numpy(compute_gradient(objective, control)))
            return sensitivities_numpy
        elif wrt is None:
            controls_fenics = [Control(i) for i in controls]
        sensitivities_numpy = [to_numpy(compute_gradient(objective, i)) for i in controls_fenics]
        return sensitivities_numpy

    @abstractmethod
    def problem(self, controls):
        &#39;&#39;&#39; Define the optimization problem. This method should be overloaded in the child class.
        Args:
            controls (list): list of fenics.Functions that will be used as control.
            templates (list): list of function spaces of the controls.
        Returns:
            AdjFroat: objective float value.
        &#39;&#39;&#39;
        raise NotImplementedError(&#39;problem method is not implemented.&#39;)

    def forward(self, controls):
        &#39;&#39;&#39; Compute the objective value based on the problem method.
        Args:
            controls (list): list of fenics.Functions that will be used as control.
            templates (list): list of function spaces of the controls.
        Returns:
            AdjFroat: objective float value.
        &#39;&#39;&#39;        
        self.controls_fenics = controls
        self.objective = self.problem(self.controls_fenics)
        self.log_obj.append(self.objective)
        self.index += 1
        return self.objective

    def backward(self, wrt=None):
        &#39;&#39;&#39; Compute the sensitivities of the objective value w.r.t. `wrt` indices.
        Args:
            wrt (list, optional): Automatic derivative of objective w.r.t. wrt index. Defaults to None to calculate sensitivities for all controls.
        Returns:
            list: list of numpy array.
        &#39;&#39;&#39;        
        sensitivities = self.__compute_sensitivities(self.objective, self.controls_fenics, wrt)
        return sensitivities

    def backward_constraint(self, target, wrt=None):
        &#39;&#39;&#39; Compute the sensitivities of the constraint value w.r.t. `wrt` indices.
        Args:
            target (str): name of the constraint function.
            wrt (list, optional): Automatic derivative of objective w.r.t. wrt index. Defaults to None to calculate sensitivities for all controls.
        Returns:
            list: list of numpy array.
        &#39;&#39;&#39;
        sensitivities = self.__compute_sensitivities(getattr(self, target)(), self.controls_fenics, wrt)
        return sensitivities</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="optfx.core.Module"><code class="flex name class">
<span>class <span class="ident">Module</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Module(metaclass=ABCMeta):
    index = int(0)
    log_obj = [0]
    &#39;&#39;&#39;
    Core module of the fenics-optimize. The Module class is an abstract class that defines 
    the basic methods and attributes of the optimization problem.
    &#39;&#39;&#39;     
    def __compute_sensitivities(self, objective, controls, wrt) -&gt; list[np.ndarray]:
        &#39;&#39;&#39;Computes the sensitivities of the optimization problem with respect to the control variables.

        Args:
            objective: The objective function being optimized.
            controls: A list of the control variables.
            wrt: Either an integer index or a list of integer indices indicating which control variables to compute sensitivities for.

        Returns:
            A list of NumPy arrays containing the sensitivities of the objective function with respect to the specified control variables.
        &#39;&#39;&#39;
        if isinstance(wrt, Iterable):
            sensitivities_numpy = []
            for i in range(len(controls)):
                if i not in wrt:
                    sensitivities_numpy.append(to_numpy(controls[i])*0.0)
                else:
                    control = Control(controls[i])
                    sensitivities_numpy.append(to_numpy(compute_gradient(objective, control)))
            return sensitivities_numpy
        elif wrt is None:
            controls_fenics = [Control(i) for i in controls]
        sensitivities_numpy = [to_numpy(compute_gradient(objective, i)) for i in controls_fenics]
        return sensitivities_numpy

    @abstractmethod
    def problem(self, controls):
        &#39;&#39;&#39; Define the optimization problem. This method should be overloaded in the child class.
        Args:
            controls (list): list of fenics.Functions that will be used as control.
            templates (list): list of function spaces of the controls.
        Returns:
            AdjFroat: objective float value.
        &#39;&#39;&#39;
        raise NotImplementedError(&#39;problem method is not implemented.&#39;)

    def forward(self, controls):
        &#39;&#39;&#39; Compute the objective value based on the problem method.
        Args:
            controls (list): list of fenics.Functions that will be used as control.
            templates (list): list of function spaces of the controls.
        Returns:
            AdjFroat: objective float value.
        &#39;&#39;&#39;        
        self.controls_fenics = controls
        self.objective = self.problem(self.controls_fenics)
        self.log_obj.append(self.objective)
        self.index += 1
        return self.objective

    def backward(self, wrt=None):
        &#39;&#39;&#39; Compute the sensitivities of the objective value w.r.t. `wrt` indices.
        Args:
            wrt (list, optional): Automatic derivative of objective w.r.t. wrt index. Defaults to None to calculate sensitivities for all controls.
        Returns:
            list: list of numpy array.
        &#39;&#39;&#39;        
        sensitivities = self.__compute_sensitivities(self.objective, self.controls_fenics, wrt)
        return sensitivities

    def backward_constraint(self, target, wrt=None):
        &#39;&#39;&#39; Compute the sensitivities of the constraint value w.r.t. `wrt` indices.
        Args:
            target (str): name of the constraint function.
            wrt (list, optional): Automatic derivative of objective w.r.t. wrt index. Defaults to None to calculate sensitivities for all controls.
        Returns:
            list: list of numpy array.
        &#39;&#39;&#39;
        sensitivities = self.__compute_sensitivities(getattr(self, target)(), self.controls_fenics, wrt)
        return sensitivities</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="optfx.core.Module.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="optfx.core.Module.log_obj"><code class="name">var <span class="ident">log_obj</span></code></dt>
<dd>
<div class="desc"><p>Core module of the fenics-optimize. The Module class is an abstract class that defines
the basic methods and attributes of the optimization problem.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="optfx.core.Module.backward"><code class="name flex">
<span>def <span class="ident">backward</span></span>(<span>self, wrt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the sensitivities of the objective value w.r.t. <code>wrt</code> indices.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wrt</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Automatic derivative of objective w.r.t. wrt index. Defaults to None to calculate sensitivities for all controls.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>list of numpy array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backward(self, wrt=None):
    &#39;&#39;&#39; Compute the sensitivities of the objective value w.r.t. `wrt` indices.
    Args:
        wrt (list, optional): Automatic derivative of objective w.r.t. wrt index. Defaults to None to calculate sensitivities for all controls.
    Returns:
        list: list of numpy array.
    &#39;&#39;&#39;        
    sensitivities = self.__compute_sensitivities(self.objective, self.controls_fenics, wrt)
    return sensitivities</code></pre>
</details>
</dd>
<dt id="optfx.core.Module.backward_constraint"><code class="name flex">
<span>def <span class="ident">backward_constraint</span></span>(<span>self, target, wrt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the sensitivities of the constraint value w.r.t. <code>wrt</code> indices.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the constraint function.</dd>
<dt><strong><code>wrt</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>Automatic derivative of objective w.r.t. wrt index. Defaults to None to calculate sensitivities for all controls.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>list of numpy array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backward_constraint(self, target, wrt=None):
    &#39;&#39;&#39; Compute the sensitivities of the constraint value w.r.t. `wrt` indices.
    Args:
        target (str): name of the constraint function.
        wrt (list, optional): Automatic derivative of objective w.r.t. wrt index. Defaults to None to calculate sensitivities for all controls.
    Returns:
        list: list of numpy array.
    &#39;&#39;&#39;
    sensitivities = self.__compute_sensitivities(getattr(self, target)(), self.controls_fenics, wrt)
    return sensitivities</code></pre>
</details>
</dd>
<dt id="optfx.core.Module.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, controls)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the objective value based on the problem method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>controls</code></strong> :&ensp;<code>list</code></dt>
<dd>list of fenics.Functions that will be used as control.</dd>
<dt><strong><code>templates</code></strong> :&ensp;<code>list</code></dt>
<dd>list of function spaces of the controls.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>AdjFroat</code></dt>
<dd>objective float value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def forward(self, controls):
    &#39;&#39;&#39; Compute the objective value based on the problem method.
    Args:
        controls (list): list of fenics.Functions that will be used as control.
        templates (list): list of function spaces of the controls.
    Returns:
        AdjFroat: objective float value.
    &#39;&#39;&#39;        
    self.controls_fenics = controls
    self.objective = self.problem(self.controls_fenics)
    self.log_obj.append(self.objective)
    self.index += 1
    return self.objective</code></pre>
</details>
</dd>
<dt id="optfx.core.Module.problem"><code class="name flex">
<span>def <span class="ident">problem</span></span>(<span>self, controls)</span>
</code></dt>
<dd>
<div class="desc"><p>Define the optimization problem. This method should be overloaded in the child class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>controls</code></strong> :&ensp;<code>list</code></dt>
<dd>list of fenics.Functions that will be used as control.</dd>
<dt><strong><code>templates</code></strong> :&ensp;<code>list</code></dt>
<dd>list of function spaces of the controls.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>AdjFroat</code></dt>
<dd>objective float value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def problem(self, controls):
    &#39;&#39;&#39; Define the optimization problem. This method should be overloaded in the child class.
    Args:
        controls (list): list of fenics.Functions that will be used as control.
        templates (list): list of function spaces of the controls.
    Returns:
        AdjFroat: objective float value.
    &#39;&#39;&#39;
    raise NotImplementedError(&#39;problem method is not implemented.&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="optfx" href="index.html">optfx</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="optfx.core.Module" href="#optfx.core.Module">Module</a></code></h4>
<ul class="two-column">
<li><code><a title="optfx.core.Module.backward" href="#optfx.core.Module.backward">backward</a></code></li>
<li><code><a title="optfx.core.Module.backward_constraint" href="#optfx.core.Module.backward_constraint">backward_constraint</a></code></li>
<li><code><a title="optfx.core.Module.forward" href="#optfx.core.Module.forward">forward</a></code></li>
<li><code><a title="optfx.core.Module.index" href="#optfx.core.Module.index">index</a></code></li>
<li><code><a title="optfx.core.Module.log_obj" href="#optfx.core.Module.log_obj">log_obj</a></code></li>
<li><code><a title="optfx.core.Module.problem" href="#optfx.core.Module.problem">problem</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>