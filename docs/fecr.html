<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>optimize.fecr API documentation</title>
<meta name="description" content="Backends in `numpy-fem-adjoint` are organized to meet the following requirements
- backends are not imported unless those are actually needed,
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>optimize.fecr</code></h1>
</header>
<section id="section-intro">
<p>Backends in <code>numpy-fem-adjoint</code> are organized to meet the following requirements
- backends are not imported unless those are actually needed, because
- backends may not be installed
- importing all available backends will drive to significant memory footprint
- backends may by present but installed with errors (but never used),
importing may drive to crashes
- backend should be either symbolic or imperative (tensorflow is for both, but that causes problems)
- this determines which methods (from_numpy/to_numpy or create_symbol/eval_symbol) should be defined
- if backend can't (temporarily) provide symbols for shape dimensions, UnknownSize objects are used</p>
<p>MIT License</p>
<p>Copyright (c) 2020 Ivan Yashchuk</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#! /usr/bin/python3
# -*- coding: utf-8 -*-
# The backends pattern was borrowed from einops package
# https://github.com/arogozhnikov/einops/blob/7a1bfb8738d33bdba3fa94de713814c0b2848c59/einops/_backends.py
&#39;&#39;&#39;
Backends in `numpy-fem-adjoint` are organized to meet the following requirements
- backends are not imported unless those are actually needed, because
    - backends may not be installed
    - importing all available backends will drive to significant memory footprint
    - backends may by present but installed with errors (but never used),
      importing may drive to crashes
- backend should be either symbolic or imperative (tensorflow is for both, but that causes problems)
    - this determines which methods (from_numpy/to_numpy or create_symbol/eval_symbol) should be defined
- if backend can&#39;t (temporarily) provide symbols for shape dimensions, UnknownSize objects are used

MIT License

Copyright (c) 2020 Ivan Yashchuk

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the &#34;Software&#34;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
&#39;&#39;&#39;
import numpy as np
import warnings
from typing import Collection
import sys
from typing import Collection
from dataclasses import dataclass
import pyadjoint
import numpy as np

_backends = {}
_debug_importing = False

@dataclass
class BackendVariable:
    block_variable: pyadjoint.block_variable.BlockVariable


class AbstractBackend:
    &#34;&#34;&#34;Base backend class, major part of methods are only for debugging purposes. &#34;&#34;&#34;

    framework_name: str

    def is_appropriate_type(self, tensor):
        &#34;&#34;&#34; helper method should recognize fem variables it can handle &#34;&#34;&#34;
        raise NotImplementedError()

    @property
    def Function(self):
        raise NotImplementedError()

    @property
    def lib(self):
        raise NotImplementedError()

    def to_numpy(self, x):
        raise NotImplementedError()

    def from_numpy(self, x, template):
        raise NotImplementedError()

    def __repr__(self):
        return &#34;&lt;numpy-fem-adjoint backend for {}&gt;&#34;.format(self.framework_name)

def get_backend(fem_variable) -&gt; AbstractBackend:
    &#34;&#34;&#34;
    Takes a correct backend (e.g. Firedrake backend if Function is firedrake.Function) for a fem variable.
    If needed, imports package and creates backend
    &#34;&#34;&#34;
    for framework_name, backend in _backends.items():
        if backend.is_appropriate_type(fem_variable):
            return backend

    # Find backend subclasses recursively
    backend_subclasses = []
    backends = AbstractBackend.__subclasses__()
    while backends:
        backend = backends.pop()
        backends += backend.__subclasses__()
        backend_subclasses.append(backend)

    for BackendSubclass in backend_subclasses:
        if _debug_importing:
            print(&#34;Testing for subclass of &#34;, BackendSubclass)
        if BackendSubclass.framework_name not in _backends:
            # check that module was already imported. Otherwise it can&#39;t be imported
            if BackendSubclass.framework_name in sys.modules:
                if _debug_importing:
                    print(&#34;Imported backend for &#34;, BackendSubclass.framework_name)
                backend = BackendSubclass()
                _backends[backend.framework_name] = backend
                if backend.is_appropriate_type(fem_variable):
                    return backend

    raise RuntimeError(
        &#34;Type unknown to numpy-fem-adjoint {}&#34;.format(type(fem_variable))
    )

class FenicsBackend(AbstractBackend):
    framework_name = &#34;fenics&#34;

    def __init__(self):
        import fenics

        self.fenics = fenics

    @property
    def Function(self):
        return self.fenics.Function

    @property
    def lib(self):
        return self.fenics

    def is_appropriate_type(self, fem_variable):
        if isinstance(fem_variable, self.fenics.Constant):
            return True
        if isinstance(fem_variable, self.fenics.Function):
            return True
        if isinstance(fem_variable, self.fenics.GenericVector):
            return True
        return False

    def to_numpy(self, fenics_var):
        &#34;&#34;&#34;Convert FEniCS variable to NumPy array.
        Serializes the input so that all MPI ranks have the same data.&#34;&#34;&#34;
        if isinstance(fenics_var, self.fenics.Constant):
            return np.asarray(fenics_var.values())

        if isinstance(fenics_var, self.fenics.GenericVector):
            if fenics_var.mpi_comm().size &gt; 1:
                data = fenics_var.gather(np.arange(fenics_var.size(), dtype=&#34;I&#34;))
            else:
                data = fenics_var.get_local()
            return np.asarray(data)

        if isinstance(fenics_var, self.fenics.Function):
            fenics_vec = fenics_var.vector()
            return self.to_numpy(fenics_vec)

        raise ValueError(&#34;Cannot convert &#34; + str(type(fenics_var)))

    def from_numpy(self, numpy_array, fenics_var_template):
        &#34;&#34;&#34;Convert NumPy array to FEniCS variable.
        Distributes the input array across MPI ranks.
        Input:
            numpy_array (np.array): NumPy array to be converted to FEniCS type
            fenics_var_template (FenicsVariable): Templates for converting arrays to FEniCS type
        Output:
            fenucs_output (FenicsVariable): FEniCS representation of the input numpy_array
        &#34;&#34;&#34;

        if isinstance(fenics_var_template, self.fenics.Constant):
            if numpy_array.shape == (1,):
                return type(fenics_var_template)(numpy_array[0])
            else:
                return type(fenics_var_template)(numpy_array)

        if isinstance(fenics_var_template, self.fenics.Function):
            function_space = fenics_var_template.function_space()

            u = type(fenics_var_template)(function_space)

            # assume that given numpy array is global array that needs to be distrubuted across processes
            # when FEniCS function is created
            fenics_size = u.vector().size()
            np_size = numpy_array.size

            if np_size != fenics_size:
                err_msg = (
                    f&#34;Cannot convert numpy array to Function:&#34;
                    f&#34;Wrong size {numpy_array.size} vs {u.vector().size()}&#34;
                )
                raise ValueError(err_msg)

            if numpy_array.dtype != np.float_:
                err_msg = (
                    f&#34;The numpy array must be of type {np.float_}, &#34;
                    &#34;but got {numpy_array.dtype}&#34;
                )
                raise ValueError(err_msg)

            range_begin, range_end = u.vector().local_range()
            numpy_array = np.asarray(numpy_array)
            local_array = numpy_array.reshape(fenics_size)[range_begin:range_end]
            # TODO: replace with a Firedrake-way of setting local portion of data (probably u.dat.data)
            u.vector().set_local(local_array)
            u.vector().apply(&#34;insert&#34;)
            return u

        err_msg = f&#34;Cannot convert numpy array to {fenics_var_template}&#34;
        raise ValueError(err_msg)

class PyadjointBackend(AbstractBackend):
    framework_name = &#34;pyadjoint&#34;

    def __init__(self):
        import pyadjoint

        self.pyadjoint = pyadjoint

    def is_appropriate_type(self, fem_variable):
        return isinstance(fem_variable, (self.pyadjoint.AdjFloat, float))

    def to_numpy(self, pyadjoint_var):
        &#34;&#34;&#34;Convert pyadjoint float variable to NumPy array.&#34;&#34;&#34;
        if isinstance(pyadjoint_var, (self.pyadjoint.AdjFloat, float)):
            return np.asarray(pyadjoint_var)
        raise ValueError(&#34;Cannot convert &#34; + str(type(pyadjoint_var)))

    def from_numpy(self, numpy_array, pyadjoint_var_template):
        &#34;&#34;&#34;Convert scalar numpy array to float that pyadjoint understands.
        Input:
            numpy_array (np.array): NumPy array to be converted to pyadjoint type
            pyadjoint_var_template (PyadjointVariable): Templates for converting arrays to pyadjoint type
        Output:
            (FiredrakeVariable): pyadjoint representation of the input numpy_array
        &#34;&#34;&#34;
        if isinstance(pyadjoint_var_template, self.pyadjoint.AdjFloat):
            return float(numpy_array)
        err_msg = f&#34;Cannot convert numpy array to {pyadjoint_var_template}&#34;
        raise ValueError(err_msg)

def to_numpy(fem_variable: BackendVariable) -&gt; np.array:
    &#34;&#34;&#34;Convert fem_variable to NumPy array.
    Serializes the input so that all MPI ranks have the same data.&#34;&#34;&#34;
    backend = get_backend(fem_variable)
    return backend.to_numpy(fem_variable)


def from_numpy(numpy_array: np.array, backend_var_template: BackendVariable):
    &#34;&#34;&#34;Convert NumPy array to Firedrake variable.
    Distributes the input array across MPI ranks.
    Input:
        numpy_array (np.array): NumPy array to be converted to FEM backend type
        backend_var_template (BackendVariable): Templates for converting arrays to FEM backend type
    Output:
        (BackendVariable): FEM backend representation of the input numpy_array
    &#34;&#34;&#34;
    backend = get_backend(backend_var_template)
    return backend.from_numpy(numpy_array, backend_var_template)


def get_numpy_input_templates(
    backend_input_templates: Collection[BackendVariable],
) -&gt; Collection[np.array]:
    &#34;&#34;&#34;Returns a collection of numpy representations of the input templates&#34;&#34;&#34;
    numpy_input_templates = [to_numpy(x) for x in backend_input_templates]
    return numpy_input_templates


def check_input(
    backend_templates: Collection[BackendVariable], *args: np.array
) -&gt; None:
    &#34;&#34;&#34;Checks that the number of inputs arguments is correct&#34;&#34;&#34;
    n_args = len(args)
    expected_nargs = len(backend_templates)
    if n_args != expected_nargs:
        raise ValueError(
            &#34;Wrong number of arguments&#34;
            &#34; Expected {} got {}.&#34;.format(expected_nargs, n_args)
        )

    # Check that each input argument has correct dimensions
    numpy_templates = get_numpy_input_templates(backend_templates)
    for i, (arg, template) in enumerate(zip(args, numpy_templates)):
        if arg.shape != template.shape:
            raise ValueError(
                &#34;Expected input shape {} for input&#34;
                &#34; {} but got {}.&#34;.format(template.shape, i, arg.shape)
            )

    # Check that the inputs are of double precision
    for i, arg in enumerate(args):
        if arg.dtype != np.float64:
            raise TypeError(
                &#34;All inputs must be type {},&#34;
                &#34; but got {} for input {}.&#34;.format(np.float64, arg.dtype, i)
            )


def convert_all_to_backend(
    backend_templates: Collection[BackendVariable], *args: np.array
) -&gt; Collection[BackendVariable]:
    &#34;&#34;&#34;Converts input array to corresponding backend variables&#34;&#34;&#34;
    backend_inputs = []
    for inp, template in zip(args, backend_templates):
        backend_inputs.append(from_numpy(inp, template))
    return backend_inputs</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="optimize.fecr.check_input"><code class="name flex">
<span>def <span class="ident">check_input</span></span>(<span>backend_templates:Â Collection[<a title="optimize.fecr.BackendVariable" href="#optimize.fecr.BackendVariable">BackendVariable</a>], *args:Â <built-inÂ functionÂ array>) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Checks that the number of inputs arguments is correct</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_input(
    backend_templates: Collection[BackendVariable], *args: np.array
) -&gt; None:
    &#34;&#34;&#34;Checks that the number of inputs arguments is correct&#34;&#34;&#34;
    n_args = len(args)
    expected_nargs = len(backend_templates)
    if n_args != expected_nargs:
        raise ValueError(
            &#34;Wrong number of arguments&#34;
            &#34; Expected {} got {}.&#34;.format(expected_nargs, n_args)
        )

    # Check that each input argument has correct dimensions
    numpy_templates = get_numpy_input_templates(backend_templates)
    for i, (arg, template) in enumerate(zip(args, numpy_templates)):
        if arg.shape != template.shape:
            raise ValueError(
                &#34;Expected input shape {} for input&#34;
                &#34; {} but got {}.&#34;.format(template.shape, i, arg.shape)
            )

    # Check that the inputs are of double precision
    for i, arg in enumerate(args):
        if arg.dtype != np.float64:
            raise TypeError(
                &#34;All inputs must be type {},&#34;
                &#34; but got {} for input {}.&#34;.format(np.float64, arg.dtype, i)
            )</code></pre>
</details>
</dd>
<dt id="optimize.fecr.convert_all_to_backend"><code class="name flex">
<span>def <span class="ident">convert_all_to_backend</span></span>(<span>backend_templates:Â Collection[<a title="optimize.fecr.BackendVariable" href="#optimize.fecr.BackendVariable">BackendVariable</a>], *args:Â <built-inÂ functionÂ array>) â€‘>Â Collection[<a title="optimize.fecr.BackendVariable" href="#optimize.fecr.BackendVariable">BackendVariable</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Converts input array to corresponding backend variables</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_all_to_backend(
    backend_templates: Collection[BackendVariable], *args: np.array
) -&gt; Collection[BackendVariable]:
    &#34;&#34;&#34;Converts input array to corresponding backend variables&#34;&#34;&#34;
    backend_inputs = []
    for inp, template in zip(args, backend_templates):
        backend_inputs.append(from_numpy(inp, template))
    return backend_inputs</code></pre>
</details>
</dd>
<dt id="optimize.fecr.from_numpy"><code class="name flex">
<span>def <span class="ident">from_numpy</span></span>(<span>numpy_array:Â <built-inÂ functionÂ array>, backend_var_template:Â <a title="optimize.fecr.BackendVariable" href="#optimize.fecr.BackendVariable">BackendVariable</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert NumPy array to Firedrake variable.
Distributes the input array across MPI ranks.</p>
<h2 id="input">Input</h2>
<p>numpy_array (np.array): NumPy array to be converted to FEM backend type
backend_var_template (BackendVariable): Templates for converting arrays to FEM backend type</p>
<h2 id="output">Output</h2>
<p>(BackendVariable): FEM backend representation of the input numpy_array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_numpy(numpy_array: np.array, backend_var_template: BackendVariable):
    &#34;&#34;&#34;Convert NumPy array to Firedrake variable.
    Distributes the input array across MPI ranks.
    Input:
        numpy_array (np.array): NumPy array to be converted to FEM backend type
        backend_var_template (BackendVariable): Templates for converting arrays to FEM backend type
    Output:
        (BackendVariable): FEM backend representation of the input numpy_array
    &#34;&#34;&#34;
    backend = get_backend(backend_var_template)
    return backend.from_numpy(numpy_array, backend_var_template)</code></pre>
</details>
</dd>
<dt id="optimize.fecr.get_backend"><code class="name flex">
<span>def <span class="ident">get_backend</span></span>(<span>fem_variable) â€‘>Â <a title="optimize.fecr.AbstractBackend" href="#optimize.fecr.AbstractBackend">AbstractBackend</a></span>
</code></dt>
<dd>
<div class="desc"><p>Takes a correct backend (e.g. Firedrake backend if Function is firedrake.Function) for a fem variable.
If needed, imports package and creates backend</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_backend(fem_variable) -&gt; AbstractBackend:
    &#34;&#34;&#34;
    Takes a correct backend (e.g. Firedrake backend if Function is firedrake.Function) for a fem variable.
    If needed, imports package and creates backend
    &#34;&#34;&#34;
    for framework_name, backend in _backends.items():
        if backend.is_appropriate_type(fem_variable):
            return backend

    # Find backend subclasses recursively
    backend_subclasses = []
    backends = AbstractBackend.__subclasses__()
    while backends:
        backend = backends.pop()
        backends += backend.__subclasses__()
        backend_subclasses.append(backend)

    for BackendSubclass in backend_subclasses:
        if _debug_importing:
            print(&#34;Testing for subclass of &#34;, BackendSubclass)
        if BackendSubclass.framework_name not in _backends:
            # check that module was already imported. Otherwise it can&#39;t be imported
            if BackendSubclass.framework_name in sys.modules:
                if _debug_importing:
                    print(&#34;Imported backend for &#34;, BackendSubclass.framework_name)
                backend = BackendSubclass()
                _backends[backend.framework_name] = backend
                if backend.is_appropriate_type(fem_variable):
                    return backend

    raise RuntimeError(
        &#34;Type unknown to numpy-fem-adjoint {}&#34;.format(type(fem_variable))
    )</code></pre>
</details>
</dd>
<dt id="optimize.fecr.get_numpy_input_templates"><code class="name flex">
<span>def <span class="ident">get_numpy_input_templates</span></span>(<span>backend_input_templates:Â Collection[<a title="optimize.fecr.BackendVariable" href="#optimize.fecr.BackendVariable">BackendVariable</a>]) â€‘>Â Collection[<built-inÂ functionÂ array>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a collection of numpy representations of the input templates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_numpy_input_templates(
    backend_input_templates: Collection[BackendVariable],
) -&gt; Collection[np.array]:
    &#34;&#34;&#34;Returns a collection of numpy representations of the input templates&#34;&#34;&#34;
    numpy_input_templates = [to_numpy(x) for x in backend_input_templates]
    return numpy_input_templates</code></pre>
</details>
</dd>
<dt id="optimize.fecr.to_numpy"><code class="name flex">
<span>def <span class="ident">to_numpy</span></span>(<span>fem_variable:Â <a title="optimize.fecr.BackendVariable" href="#optimize.fecr.BackendVariable">BackendVariable</a>) â€‘>Â <built-inÂ functionÂ array></span>
</code></dt>
<dd>
<div class="desc"><p>Convert fem_variable to NumPy array.
Serializes the input so that all MPI ranks have the same data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_numpy(fem_variable: BackendVariable) -&gt; np.array:
    &#34;&#34;&#34;Convert fem_variable to NumPy array.
    Serializes the input so that all MPI ranks have the same data.&#34;&#34;&#34;
    backend = get_backend(fem_variable)
    return backend.to_numpy(fem_variable)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="optimize.fecr.AbstractBackend"><code class="flex name class">
<span>class <span class="ident">AbstractBackend</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base backend class, major part of methods are only for debugging purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractBackend:
    &#34;&#34;&#34;Base backend class, major part of methods are only for debugging purposes. &#34;&#34;&#34;

    framework_name: str

    def is_appropriate_type(self, tensor):
        &#34;&#34;&#34; helper method should recognize fem variables it can handle &#34;&#34;&#34;
        raise NotImplementedError()

    @property
    def Function(self):
        raise NotImplementedError()

    @property
    def lib(self):
        raise NotImplementedError()

    def to_numpy(self, x):
        raise NotImplementedError()

    def from_numpy(self, x, template):
        raise NotImplementedError()

    def __repr__(self):
        return &#34;&lt;numpy-fem-adjoint backend for {}&gt;&#34;.format(self.framework_name)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="optimize.fecr.FenicsBackend" href="#optimize.fecr.FenicsBackend">FenicsBackend</a></li>
<li><a title="optimize.fecr.PyadjointBackend" href="#optimize.fecr.PyadjointBackend">PyadjointBackend</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="optimize.fecr.AbstractBackend.framework_name"><code class="name">var <span class="ident">framework_name</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="optimize.fecr.AbstractBackend.Function"><code class="name">var <span class="ident">Function</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Function(self):
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="optimize.fecr.AbstractBackend.lib"><code class="name">var <span class="ident">lib</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lib(self):
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="optimize.fecr.AbstractBackend.from_numpy"><code class="name flex">
<span>def <span class="ident">from_numpy</span></span>(<span>self, x, template)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_numpy(self, x, template):
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="optimize.fecr.AbstractBackend.is_appropriate_type"><code class="name flex">
<span>def <span class="ident">is_appropriate_type</span></span>(<span>self, tensor)</span>
</code></dt>
<dd>
<div class="desc"><p>helper method should recognize fem variables it can handle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_appropriate_type(self, tensor):
    &#34;&#34;&#34; helper method should recognize fem variables it can handle &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="optimize.fecr.AbstractBackend.to_numpy"><code class="name flex">
<span>def <span class="ident">to_numpy</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_numpy(self, x):
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="optimize.fecr.BackendVariable"><code class="flex name class">
<span>class <span class="ident">BackendVariable</span></span>
<span>(</span><span>block_variable:Â pyadjoint.block_variable.BlockVariable)</span>
</code></dt>
<dd>
<div class="desc"><p>BackendVariable(block_variable: pyadjoint.block_variable.BlockVariable)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BackendVariable:
    block_variable: pyadjoint.block_variable.BlockVariable</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="optimize.fecr.BackendVariable.block_variable"><code class="name">var <span class="ident">block_variable</span> :Â pyadjoint.block_variable.BlockVariable</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="optimize.fecr.FenicsBackend"><code class="flex name class">
<span>class <span class="ident">FenicsBackend</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base backend class, major part of methods are only for debugging purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FenicsBackend(AbstractBackend):
    framework_name = &#34;fenics&#34;

    def __init__(self):
        import fenics

        self.fenics = fenics

    @property
    def Function(self):
        return self.fenics.Function

    @property
    def lib(self):
        return self.fenics

    def is_appropriate_type(self, fem_variable):
        if isinstance(fem_variable, self.fenics.Constant):
            return True
        if isinstance(fem_variable, self.fenics.Function):
            return True
        if isinstance(fem_variable, self.fenics.GenericVector):
            return True
        return False

    def to_numpy(self, fenics_var):
        &#34;&#34;&#34;Convert FEniCS variable to NumPy array.
        Serializes the input so that all MPI ranks have the same data.&#34;&#34;&#34;
        if isinstance(fenics_var, self.fenics.Constant):
            return np.asarray(fenics_var.values())

        if isinstance(fenics_var, self.fenics.GenericVector):
            if fenics_var.mpi_comm().size &gt; 1:
                data = fenics_var.gather(np.arange(fenics_var.size(), dtype=&#34;I&#34;))
            else:
                data = fenics_var.get_local()
            return np.asarray(data)

        if isinstance(fenics_var, self.fenics.Function):
            fenics_vec = fenics_var.vector()
            return self.to_numpy(fenics_vec)

        raise ValueError(&#34;Cannot convert &#34; + str(type(fenics_var)))

    def from_numpy(self, numpy_array, fenics_var_template):
        &#34;&#34;&#34;Convert NumPy array to FEniCS variable.
        Distributes the input array across MPI ranks.
        Input:
            numpy_array (np.array): NumPy array to be converted to FEniCS type
            fenics_var_template (FenicsVariable): Templates for converting arrays to FEniCS type
        Output:
            fenucs_output (FenicsVariable): FEniCS representation of the input numpy_array
        &#34;&#34;&#34;

        if isinstance(fenics_var_template, self.fenics.Constant):
            if numpy_array.shape == (1,):
                return type(fenics_var_template)(numpy_array[0])
            else:
                return type(fenics_var_template)(numpy_array)

        if isinstance(fenics_var_template, self.fenics.Function):
            function_space = fenics_var_template.function_space()

            u = type(fenics_var_template)(function_space)

            # assume that given numpy array is global array that needs to be distrubuted across processes
            # when FEniCS function is created
            fenics_size = u.vector().size()
            np_size = numpy_array.size

            if np_size != fenics_size:
                err_msg = (
                    f&#34;Cannot convert numpy array to Function:&#34;
                    f&#34;Wrong size {numpy_array.size} vs {u.vector().size()}&#34;
                )
                raise ValueError(err_msg)

            if numpy_array.dtype != np.float_:
                err_msg = (
                    f&#34;The numpy array must be of type {np.float_}, &#34;
                    &#34;but got {numpy_array.dtype}&#34;
                )
                raise ValueError(err_msg)

            range_begin, range_end = u.vector().local_range()
            numpy_array = np.asarray(numpy_array)
            local_array = numpy_array.reshape(fenics_size)[range_begin:range_end]
            # TODO: replace with a Firedrake-way of setting local portion of data (probably u.dat.data)
            u.vector().set_local(local_array)
            u.vector().apply(&#34;insert&#34;)
            return u

        err_msg = f&#34;Cannot convert numpy array to {fenics_var_template}&#34;
        raise ValueError(err_msg)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="optimize.fecr.AbstractBackend" href="#optimize.fecr.AbstractBackend">AbstractBackend</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="optimize.fecr.FenicsBackend.framework_name"><code class="name">var <span class="ident">framework_name</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="optimize.fecr.FenicsBackend.Function"><code class="name">var <span class="ident">Function</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Function(self):
    return self.fenics.Function</code></pre>
</details>
</dd>
<dt id="optimize.fecr.FenicsBackend.lib"><code class="name">var <span class="ident">lib</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lib(self):
    return self.fenics</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="optimize.fecr.FenicsBackend.from_numpy"><code class="name flex">
<span>def <span class="ident">from_numpy</span></span>(<span>self, numpy_array, fenics_var_template)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert NumPy array to FEniCS variable.
Distributes the input array across MPI ranks.</p>
<h2 id="input">Input</h2>
<p>numpy_array (np.array): NumPy array to be converted to FEniCS type
fenics_var_template (FenicsVariable): Templates for converting arrays to FEniCS type</p>
<h2 id="output">Output</h2>
<p>fenucs_output (FenicsVariable): FEniCS representation of the input numpy_array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_numpy(self, numpy_array, fenics_var_template):
    &#34;&#34;&#34;Convert NumPy array to FEniCS variable.
    Distributes the input array across MPI ranks.
    Input:
        numpy_array (np.array): NumPy array to be converted to FEniCS type
        fenics_var_template (FenicsVariable): Templates for converting arrays to FEniCS type
    Output:
        fenucs_output (FenicsVariable): FEniCS representation of the input numpy_array
    &#34;&#34;&#34;

    if isinstance(fenics_var_template, self.fenics.Constant):
        if numpy_array.shape == (1,):
            return type(fenics_var_template)(numpy_array[0])
        else:
            return type(fenics_var_template)(numpy_array)

    if isinstance(fenics_var_template, self.fenics.Function):
        function_space = fenics_var_template.function_space()

        u = type(fenics_var_template)(function_space)

        # assume that given numpy array is global array that needs to be distrubuted across processes
        # when FEniCS function is created
        fenics_size = u.vector().size()
        np_size = numpy_array.size

        if np_size != fenics_size:
            err_msg = (
                f&#34;Cannot convert numpy array to Function:&#34;
                f&#34;Wrong size {numpy_array.size} vs {u.vector().size()}&#34;
            )
            raise ValueError(err_msg)

        if numpy_array.dtype != np.float_:
            err_msg = (
                f&#34;The numpy array must be of type {np.float_}, &#34;
                &#34;but got {numpy_array.dtype}&#34;
            )
            raise ValueError(err_msg)

        range_begin, range_end = u.vector().local_range()
        numpy_array = np.asarray(numpy_array)
        local_array = numpy_array.reshape(fenics_size)[range_begin:range_end]
        # TODO: replace with a Firedrake-way of setting local portion of data (probably u.dat.data)
        u.vector().set_local(local_array)
        u.vector().apply(&#34;insert&#34;)
        return u

    err_msg = f&#34;Cannot convert numpy array to {fenics_var_template}&#34;
    raise ValueError(err_msg)</code></pre>
</details>
</dd>
<dt id="optimize.fecr.FenicsBackend.to_numpy"><code class="name flex">
<span>def <span class="ident">to_numpy</span></span>(<span>self, fenics_var)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert FEniCS variable to NumPy array.
Serializes the input so that all MPI ranks have the same data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_numpy(self, fenics_var):
    &#34;&#34;&#34;Convert FEniCS variable to NumPy array.
    Serializes the input so that all MPI ranks have the same data.&#34;&#34;&#34;
    if isinstance(fenics_var, self.fenics.Constant):
        return np.asarray(fenics_var.values())

    if isinstance(fenics_var, self.fenics.GenericVector):
        if fenics_var.mpi_comm().size &gt; 1:
            data = fenics_var.gather(np.arange(fenics_var.size(), dtype=&#34;I&#34;))
        else:
            data = fenics_var.get_local()
        return np.asarray(data)

    if isinstance(fenics_var, self.fenics.Function):
        fenics_vec = fenics_var.vector()
        return self.to_numpy(fenics_vec)

    raise ValueError(&#34;Cannot convert &#34; + str(type(fenics_var)))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="optimize.fecr.AbstractBackend" href="#optimize.fecr.AbstractBackend">AbstractBackend</a></b></code>:
<ul class="hlist">
<li><code><a title="optimize.fecr.AbstractBackend.is_appropriate_type" href="#optimize.fecr.AbstractBackend.is_appropriate_type">is_appropriate_type</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="optimize.fecr.PyadjointBackend"><code class="flex name class">
<span>class <span class="ident">PyadjointBackend</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base backend class, major part of methods are only for debugging purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PyadjointBackend(AbstractBackend):
    framework_name = &#34;pyadjoint&#34;

    def __init__(self):
        import pyadjoint

        self.pyadjoint = pyadjoint

    def is_appropriate_type(self, fem_variable):
        return isinstance(fem_variable, (self.pyadjoint.AdjFloat, float))

    def to_numpy(self, pyadjoint_var):
        &#34;&#34;&#34;Convert pyadjoint float variable to NumPy array.&#34;&#34;&#34;
        if isinstance(pyadjoint_var, (self.pyadjoint.AdjFloat, float)):
            return np.asarray(pyadjoint_var)
        raise ValueError(&#34;Cannot convert &#34; + str(type(pyadjoint_var)))

    def from_numpy(self, numpy_array, pyadjoint_var_template):
        &#34;&#34;&#34;Convert scalar numpy array to float that pyadjoint understands.
        Input:
            numpy_array (np.array): NumPy array to be converted to pyadjoint type
            pyadjoint_var_template (PyadjointVariable): Templates for converting arrays to pyadjoint type
        Output:
            (FiredrakeVariable): pyadjoint representation of the input numpy_array
        &#34;&#34;&#34;
        if isinstance(pyadjoint_var_template, self.pyadjoint.AdjFloat):
            return float(numpy_array)
        err_msg = f&#34;Cannot convert numpy array to {pyadjoint_var_template}&#34;
        raise ValueError(err_msg)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="optimize.fecr.AbstractBackend" href="#optimize.fecr.AbstractBackend">AbstractBackend</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="optimize.fecr.PyadjointBackend.framework_name"><code class="name">var <span class="ident">framework_name</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="optimize.fecr.PyadjointBackend.from_numpy"><code class="name flex">
<span>def <span class="ident">from_numpy</span></span>(<span>self, numpy_array, pyadjoint_var_template)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert scalar numpy array to float that pyadjoint understands.</p>
<h2 id="input">Input</h2>
<p>numpy_array (np.array): NumPy array to be converted to pyadjoint type
pyadjoint_var_template (PyadjointVariable): Templates for converting arrays to pyadjoint type</p>
<h2 id="output">Output</h2>
<p>(FiredrakeVariable): pyadjoint representation of the input numpy_array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_numpy(self, numpy_array, pyadjoint_var_template):
    &#34;&#34;&#34;Convert scalar numpy array to float that pyadjoint understands.
    Input:
        numpy_array (np.array): NumPy array to be converted to pyadjoint type
        pyadjoint_var_template (PyadjointVariable): Templates for converting arrays to pyadjoint type
    Output:
        (FiredrakeVariable): pyadjoint representation of the input numpy_array
    &#34;&#34;&#34;
    if isinstance(pyadjoint_var_template, self.pyadjoint.AdjFloat):
        return float(numpy_array)
    err_msg = f&#34;Cannot convert numpy array to {pyadjoint_var_template}&#34;
    raise ValueError(err_msg)</code></pre>
</details>
</dd>
<dt id="optimize.fecr.PyadjointBackend.to_numpy"><code class="name flex">
<span>def <span class="ident">to_numpy</span></span>(<span>self, pyadjoint_var)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert pyadjoint float variable to NumPy array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_numpy(self, pyadjoint_var):
    &#34;&#34;&#34;Convert pyadjoint float variable to NumPy array.&#34;&#34;&#34;
    if isinstance(pyadjoint_var, (self.pyadjoint.AdjFloat, float)):
        return np.asarray(pyadjoint_var)
    raise ValueError(&#34;Cannot convert &#34; + str(type(pyadjoint_var)))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="optimize.fecr.AbstractBackend" href="#optimize.fecr.AbstractBackend">AbstractBackend</a></b></code>:
<ul class="hlist">
<li><code><a title="optimize.fecr.AbstractBackend.is_appropriate_type" href="#optimize.fecr.AbstractBackend.is_appropriate_type">is_appropriate_type</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="optimize" href="index.html">optimize</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="optimize.fecr.check_input" href="#optimize.fecr.check_input">check_input</a></code></li>
<li><code><a title="optimize.fecr.convert_all_to_backend" href="#optimize.fecr.convert_all_to_backend">convert_all_to_backend</a></code></li>
<li><code><a title="optimize.fecr.from_numpy" href="#optimize.fecr.from_numpy">from_numpy</a></code></li>
<li><code><a title="optimize.fecr.get_backend" href="#optimize.fecr.get_backend">get_backend</a></code></li>
<li><code><a title="optimize.fecr.get_numpy_input_templates" href="#optimize.fecr.get_numpy_input_templates">get_numpy_input_templates</a></code></li>
<li><code><a title="optimize.fecr.to_numpy" href="#optimize.fecr.to_numpy">to_numpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="optimize.fecr.AbstractBackend" href="#optimize.fecr.AbstractBackend">AbstractBackend</a></code></h4>
<ul class="two-column">
<li><code><a title="optimize.fecr.AbstractBackend.Function" href="#optimize.fecr.AbstractBackend.Function">Function</a></code></li>
<li><code><a title="optimize.fecr.AbstractBackend.framework_name" href="#optimize.fecr.AbstractBackend.framework_name">framework_name</a></code></li>
<li><code><a title="optimize.fecr.AbstractBackend.from_numpy" href="#optimize.fecr.AbstractBackend.from_numpy">from_numpy</a></code></li>
<li><code><a title="optimize.fecr.AbstractBackend.is_appropriate_type" href="#optimize.fecr.AbstractBackend.is_appropriate_type">is_appropriate_type</a></code></li>
<li><code><a title="optimize.fecr.AbstractBackend.lib" href="#optimize.fecr.AbstractBackend.lib">lib</a></code></li>
<li><code><a title="optimize.fecr.AbstractBackend.to_numpy" href="#optimize.fecr.AbstractBackend.to_numpy">to_numpy</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="optimize.fecr.BackendVariable" href="#optimize.fecr.BackendVariable">BackendVariable</a></code></h4>
<ul class="">
<li><code><a title="optimize.fecr.BackendVariable.block_variable" href="#optimize.fecr.BackendVariable.block_variable">block_variable</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="optimize.fecr.FenicsBackend" href="#optimize.fecr.FenicsBackend">FenicsBackend</a></code></h4>
<ul class="">
<li><code><a title="optimize.fecr.FenicsBackend.Function" href="#optimize.fecr.FenicsBackend.Function">Function</a></code></li>
<li><code><a title="optimize.fecr.FenicsBackend.framework_name" href="#optimize.fecr.FenicsBackend.framework_name">framework_name</a></code></li>
<li><code><a title="optimize.fecr.FenicsBackend.from_numpy" href="#optimize.fecr.FenicsBackend.from_numpy">from_numpy</a></code></li>
<li><code><a title="optimize.fecr.FenicsBackend.lib" href="#optimize.fecr.FenicsBackend.lib">lib</a></code></li>
<li><code><a title="optimize.fecr.FenicsBackend.to_numpy" href="#optimize.fecr.FenicsBackend.to_numpy">to_numpy</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="optimize.fecr.PyadjointBackend" href="#optimize.fecr.PyadjointBackend">PyadjointBackend</a></code></h4>
<ul class="">
<li><code><a title="optimize.fecr.PyadjointBackend.framework_name" href="#optimize.fecr.PyadjointBackend.framework_name">framework_name</a></code></li>
<li><code><a title="optimize.fecr.PyadjointBackend.from_numpy" href="#optimize.fecr.PyadjointBackend.from_numpy">from_numpy</a></code></li>
<li><code><a title="optimize.fecr.PyadjointBackend.to_numpy" href="#optimize.fecr.PyadjointBackend.to_numpy">to_numpy</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>